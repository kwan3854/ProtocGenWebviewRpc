// AUTO-GENERATED by protoc-gen-webviewrpc
// TypeScript Server: {{.ServiceName}}ServiceBase

// Import encoding/decoding functions for each method
import { {{range .Methods}}decode{{.InputType}}, encode{{.OutputType}},{{end}} } from './{{.ServiceName}}';

// Type definitions for request/response messages
{{range .Methods}}
export interface {{.InputType}} {
  [key: string]: any;
}

export interface {{.OutputType}} {
  [key: string]: any;
}
{{end}}

/**
 * Abstract class for {{.ServiceName}} server implementation
 * Users (server implementors) should inherit this class and implement the methods.
 */
export abstract class {{.ServiceName}}Base {
  {{range .Methods}}
  /**
   * {{.MethodName}} method
   * @param requestObj - {{.InputType}} object
   * @returns Promise resolving to {{.OutputType}}
   */
  abstract {{.MethodName}}(requestObj: {{.InputType}}): Promise<{{.OutputType}}>;
  {{end}}
}

/**
 * Service binding utility
 * Binds a service implementation to create a ServiceDefinition
 */
export class {{.ServiceName}} {
  static bindService(impl: {{.ServiceName}}Base): ServiceDefinition {
    const def: ServiceDefinition = {
      methodHandlers: {}
    };

    {{range .Methods}}
    def.methodHandlers["{{$.ServiceName}}.{{.MethodName}}"] = async (reqBytes: Uint8Array): Promise<Uint8Array> => {
      const reqObj = decode{{.InputType}}(reqBytes);
      const respObj = await impl.{{.MethodName}}(reqObj);
      return encode{{.OutputType}}(respObj);
    };
    {{end}}

    return def;
  }
}

/**
 * Service definition structure
 */
export interface ServiceDefinition {
  methodHandlers: {
    [key: string]: (reqBytes: Uint8Array) => Promise<Uint8Array>;
  };
}

